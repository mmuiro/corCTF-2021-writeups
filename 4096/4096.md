----
title: corCTF 2021 - 4096
date: Aug 23 2021
author: qopruzjf
tags: crypto
---

# Challenge

> I heard 4096 bit RSA is secure, so I encrypted the flag with it.

# Solution

Let's take a look at `source.py`.

```python
from Crypto.Util.number import getPrime, bytes_to_long
from private import flag

def prod(lst):
	ret = 1
	for num in lst:
		ret *= num
	return ret

m = bytes_to_long(flag)
primes = [getPrime(32) for _ in range(128)]
n = prod(primes)
e = 65537
print(n)
print(pow(m, e, n))
```
So, `128` 32-bit primes were generated and multiplied together to produce the modulus for RSA encryption. Since 32-bits is small, we can just factor `n` using sage, and the likelihood that all the primes are unique is high(there are many 32-bit primes), so we can just calculate `phi(n)` as the product of `p_i - 1` for the primes `p_i`. Alternatively, just use sage's `totient` function. Then, decryption is the usual. I suggest people who aren't familiar with RSA that uses an arbitrary number of primes look into the actual math behind why it still works.

Here's the solve script:
```python
from Crypto.Util.number import long_to_bytes
n = 459885975247015080805640556741011516977197329640766993963868420109797926433366540892987268841395390677003815083264385212101691633439322325099797177448692622480464621078335184219389796838162276766514601933466475468401515898684493274917613994100522239975168457673847893881262044268360912988376575672476171112591298760495756557513258957047691316107068789781127778556052622156938314563686550649890013123308529462323524956343976590389389598189062535997792610595692423958859734240408888038654268044525127233802930885203114382004407420679618854820752321423652210263026002674421004459358125628893165197704730466465357733250277754582116729335454780585183881507464319371872816864390937163980938342321213464267167886221361565606170274949413010811340309217975928566961337873662243232735415505259424592138609448552846032645740285154650705912665026491380837092800272560626482253083963281523307784385386183075753783677135489658756755609520313684847611300385005067351044518651327694437586779518531321476281945821098370942775037752436793514318106103039341369024642099069559532445745414503597893184762282819390252433279093193434255143378230817111136472977731464704181932470261447745719555587426871560009788187914276773536835263029421459
c = 28755115299447380219865175141510816277127168995053017865115990550984575125799683185050702823351567348600828299072471787373507105523347305190934990188579267752586087083593225747175981684997138309755745359524509032537903919777044868871605615082163195170687980598583706842782998787213163456976487674758299135192443422599601908006134268958490155310804660685217691260626978944786030603741681463537491343107154880830022752091923044127859420510244685212654149762222514692807085300768408438515214359180426754805425610056804647793212776220975050809958444765557485627572244455567542349113285436767315494336729564478949697782757093180889501388671840393906428863764844923821078129810082488811253658252080197407107745563251321553018503591423447398679152763318675601718545686288006911301792697520238398588188160613822537782998910198317606647548568160063550153871090661536552353526398962780934555640261433391205589034576219843858289208904106775652085670099705038854877624295738691647401202134659947562445654410163435449737035924690998038213621986164097914575256877909759645573588363096065366890651919757816350994847106221042650232103061907896322357719105163758442738521889967022959871387866183293407447159616199193109243274307191759

def prod(lst):
	ret = 1
	for num in lst:
		ret *= num
	return ret

fs = ecm.factor(n)
fs = [p - 1 for p in fs]
phi = prod(fs)
e = 65537
d = pow(e, -1, phi)
print(long_to_bytes(pow(c, d, n)))
```
`corctf{to0_m4ny_pr1m3s55_63aeea37a6b3b22f}`

By the way, the modulus was not actually 4096 bits, but 4042 bits.

Thanks to players for trying this challenge!